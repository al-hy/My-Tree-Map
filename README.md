# My-Tree-Map
Created my own Tree map

The project required us to create our own Binary Search Tree that recursively stores an Element class in each node. The Element class stores the key and the value. There was a driver program called TestTreeMap.java that utilizes the MyTreeMap.java to store and process information, which are alphabetical letters as keys that map to numerical values. Keys and Values were inserted into the Binary Search Tree. The proper size of the tree is then output to test the efficiency of the delete and remove method. The output also displays the keys that are insert and its associated value.

The Binary Search Tree was recursively implemented, such that each node, besides the root, is a sub-tree itself. The first element added to the tree will be the root of the tree. Because it is a Binary Search Tree, any following element added will be placed accordingly to its precedence to the root. If the inserted element has a lower precedence compared to the root, then it is placed to the left of the root. If the element has a higher precedence, then it is placed to the right. In this case, we are using alphabets. If an element has the letter “C” as its key and is inserted into an empty node, then the C is the root of the tree. Next, the letter “A” is inserted, thus “A” will be inserted to the left of “C”. Lastly, if the letter “D” were to be insert, then it will go to the right of the root. The same concept goes for searching an element. Either search to the left or right of the root accordingly to the item’s precedence. Inorder traversal was actually used to guide the arrangement of the tree nodes after a deletion. Because a when a sub-tree element is deleted, and it is the root of that tree, the inorder successor is then determined in order to appropriately promote it as the new root.

A class shell was given to use: MyTreeMap.java. In the class, the Binary Tree Class was imported. It implements a MyMap interface that contains method that will utilize the Binary Search methods. The search(), insert(), delete(), promote(), inorder(), and height() methods are all used to make this class a Binary Search Tree. There is a nested private class called Element that stores the key and its associated value. The key in the MyTreeMap class also extends Comparable, which allows they keys from two elements to be compared, and is utilized in the compareTo() method in the Element class. The search() method takes the element it is going to be searching as an argument, as well it’s the tree it’ll be searching in. Depending on the precedence of the element being search, the method is recursively called to search the right or left of the root. The insert method checks to see if they the tree is empty. If the tree already exists, then it will recursively insert the element. If the key of an element already exists, then the new element is inserted along with the new associated value. The delete() method works hand in hand with the promote() method, such that if an element is deleted, then tree in which the element belongs is checked if it is a leaf or if it has children. If it is a leaf, then it is easily deleted. However, if it has children, then the promote() method is used to promote its inorder successor. The inorder() method works in hand with java.util.Set<K> to add the keys into the Set in an inorder traversal manner. The height method returns the height of the tree. The MyMap interface implements methods that calls these Binary Search Tree methods.


We had a driver program called the TestTreeMap.java. This file has a main method that tests each method, printing outputs when an element is inserted and deleted. The size of the tree is also printed to test the efficiency of our program. Furthermore, our first project, the Shopping Cart, was also used to test this program. Rather than importing the TreeMap provided by Java’s library, we used our MyTreeMap to hold the shopping cart information. To see if our program works, the same output must be displayed when using the MyTreeMap class compared to using Java’s TreeMap class.

I learned how to use Binary Tree and understand how the added methods makes the class a Binary Search Tree. This project allowed me to have a higher understanding of recursion and the various traversals for Binary Tree, such as the inorder traversal and how to locate the inorder successor of an element.
